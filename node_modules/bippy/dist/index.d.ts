import { BundleType, ComponentSelector, ContextDependency, Dependencies, DevToolsConfig, Effect, Family, Fiber, FiberRoot, Flags, HasPseudoClassSelector, HookType, HostConfig, LanePriority, Lanes, MemoizedState, MutableSource, OpaqueHandle, OpaqueRoot, Props, React$AbstractComponent, ReactConsumer, ReactContext, ReactDevToolsGlobalHook, ReactPortal, ReactProvider, ReactProviderType, ReactRenderer, RefObject, RoleSelector, RootTag, Selector, Source, SuspenseHydrationCallbacks, TestNameSelector, TextSelector, Thenable, TransitionTracingCallbacks, TypeOfMode, WorkTag } from "./types-D7j5ftmS.js";
import * as React$1 from "react";

//#region src/rdt-hook.d.ts
declare const version: string | undefined;
declare const BIPPY_INSTRUMENTATION_STRING: string;
declare const isRealReactDevtools: (rdtHook?: ReactDevToolsGlobalHook) => boolean;
declare const isReactRefresh: (rdtHook?: ReactDevToolsGlobalHook) => boolean;
declare const _renderers: Set<ReactRenderer>;
declare const installRDTHook: (onActive?: () => unknown) => ReactDevToolsGlobalHook;
declare const patchRDTHook: (onActive?: () => unknown) => void;
declare const hasRDTHook: () => boolean;
/**
 * Returns the current React DevTools global hook.
 */
declare const getRDTHook: (onActive?: () => unknown) => ReactDevToolsGlobalHook;
declare const isClientEnvironment: () => boolean;
/**
 * Usually used purely for side effect
 */
declare const safelyInstallRDTHook: () => void;

//#endregion
//#region src/core.d.ts
declare const FunctionComponentTag = 0;
declare const ClassComponentTag = 1;
declare const HostRootTag = 3;
declare const HostComponentTag = 5;
declare const HostTextTag = 6;
declare const FragmentTag = 7;
declare const ContextConsumerTag = 9;
declare const ForwardRefTag = 11;
declare const SuspenseComponentTag = 13;
declare const MemoComponentTag = 14;
declare const SimpleMemoComponentTag = 15;
declare const LazyComponentTag = 16;
declare const DehydratedSuspenseComponentTag = 18;
declare const SuspenseListComponentTag = 19;
declare const OffscreenComponentTag = 22;
declare const LegacyHiddenComponentTag = 23;
declare const HostHoistableTag = 26;
declare const HostSingletonTag = 27;
declare const ActivityComponentTag = 28;
declare const ViewTransitionComponentTag = 30;
declare const CONCURRENT_MODE_NUMBER = 60111;
declare const ELEMENT_TYPE_SYMBOL_STRING = "Symbol(react.element)";
declare const TRANSITIONAL_ELEMENT_TYPE_SYMBOL_STRING = "Symbol(react.transitional.element)";
declare const CONCURRENT_MODE_SYMBOL_STRING = "Symbol(react.concurrent_mode)";
declare const DEPRECATED_ASYNC_MODE_SYMBOL_STRING = "Symbol(react.async_mode)";
/**
 * Returns `true` if object is a React Element.
 *
 * @see https://react.dev/reference/react/isValidElement
 */
declare const isValidElement: (element: unknown) => element is React$1.ReactElement;
/**
 * Returns `true` if object is a React Fiber.
 */
declare const isValidFiber: (fiber: unknown) => fiber is Fiber;
/**
 * Returns `true` if fiber is a host fiber. Host fibers are DOM nodes in react-dom, `View` in react-native, etc.
 *
 * @see https://reactnative.dev/architecture/glossary#host-view-tree-and-host-view
 */
declare const isHostFiber: (fiber: Fiber) => boolean;
/**
 * Returns `true` if fiber is a composite fiber. Composite fibers are fibers that can render (like functional components, class components, etc.)
 *
 * @see https://reactnative.dev/architecture/glossary#react-composite-components
 */
declare const isCompositeFiber: (fiber: Fiber) => boolean;
/**
 * Returns `true` if the two {@link Fiber}s are the same reference
 */
declare const areFiberEqual: (fiberA: Fiber, fiberB: Fiber) => boolean;
/**
 * Traverses up or down a {@link Fiber}'s contexts, return `true` to stop and select the current and previous context value.
 */
declare const traverseContexts: (fiber: Fiber, selector: (nextValue: ContextDependency<unknown> | null | undefined, prevValue: ContextDependency<unknown> | null | undefined) => boolean | void) => boolean;
/**
 * Traverses up or down a {@link Fiber}'s states, return `true` to stop and select the current and previous state value. This stores both state values and effects.
 */
declare const traverseState: (fiber: Fiber, selector: (nextValue: MemoizedState | null | undefined, prevValue: MemoizedState | null | undefined) => boolean | void) => boolean;
/**
 * Traverses up or down a {@link Fiber}'s props, return `true` to stop and select the current and previous props value.
 */
declare const traverseProps: (fiber: Fiber, selector: (propName: string, nextValue: unknown, prevValue: unknown) => boolean | void) => boolean;
/**
 * Returns `true` if the {@link Fiber} has rendered. Note that this does not mean the fiber has rendered in the current commit, just that it has rendered in the past.
 */
declare const didFiberRender: (fiber: Fiber) => boolean;
/**
 * Returns `true` if the {@link Fiber} has committed. Note that this does not mean the fiber has committed in the current commit, just that it has committed in the past.
 */
declare const didFiberCommit: (fiber: Fiber) => boolean;
/**
 * Returns all host {@link Fiber}s that have committed and rendered.
 */
declare const getMutatedHostFibers: (fiber: Fiber) => Fiber[];
/**
 * Returns the stack of {@link Fiber}s from the current fiber to the root fiber.
 *
 * @example
 * ```ts
 * [fiber, fiber.return, fiber.return.return, ...]
 * ```
 */
declare const getFiberStack: (fiber: Fiber) => Fiber[];
/**
 * Returns `true` if the {@link Fiber} should be filtered out during reconciliation.
 */
declare const shouldFilterFiber: (fiber: Fiber) => boolean;
/**
 * Returns the nearest host {@link Fiber} to the current {@link Fiber}.
 */
declare const getNearestHostFiber: (fiber: Fiber, ascending?: boolean) => Fiber | null;
/**
 * Returns all host {@link Fiber}s in the tree that are associated with the current {@link Fiber}.
 */
declare const getNearestHostFibers: (fiber: Fiber) => Fiber[];
/**
 * Traverses up or down a {@link Fiber}, return `true` to stop and select a node.
 */
declare function traverseFiber(fiber: Fiber | null, selector: (node: Fiber) => boolean | void, ascending?: boolean): Fiber | null;
declare function traverseFiber(fiber: Fiber | null, selector: (node: Fiber) => Promise<boolean | void>, ascending?: boolean): Promise<Fiber | null>;
declare const traverseFiberSync: (fiber: Fiber | null, selector: (node: Fiber) => boolean | void, ascending?: boolean) => Fiber | null;
declare const traverseFiberAsync: (fiber: Fiber | null, selector: (node: Fiber) => Promise<boolean | void>, ascending?: boolean) => Promise<Fiber | null>;
/**
 * Returns the timings of the {@link Fiber}.
 *
 * @example
 * ```ts
 * const { selfTime, totalTime } = getTimings(fiber);
 * console.log(selfTime, totalTime);
 * ```
 */
declare const getTimings: (fiber?: Fiber | null) => {
  selfTime: number;
  totalTime: number;
};
/**
 * Returns `true` if the {@link Fiber} uses React Compiler's memo cache.
 */
declare const hasMemoCache: (fiber: Fiber) => boolean;
/**
 * Returns the type (e.g. component definition) of the {@link Fiber}
 */
declare const getType: (type: unknown) => null | React$1.ComponentType<unknown>;
/**
 * Returns the display name of the {@link Fiber} type.
 */
declare const getDisplayName: (type: unknown) => null | string;
/**
 * Returns the build type of the React renderer.
 */
declare const detectReactBuildType: (renderer: ReactRenderer) => "development" | "production";
/**
 * Returns `true` if bippy's instrumentation is active.
 */
declare const isInstrumentationActive: () => boolean;
/**
 * Returns the latest fiber (since it may be double-buffered).
 */
declare const getLatestFiber: (fiber: Fiber) => Fiber;
type RenderHandler = <S>(fiber: Fiber, phase: RenderPhase, state?: S) => unknown;
type RenderPhase = 'mount' | 'unmount' | 'update';
declare const fiberIdMap: WeakMap<Fiber, number>;
declare const setFiberId: (fiber: Fiber, id?: number) => void;
declare const getFiberId: (fiber: Fiber) => number;
declare const mountFiberRecursively: (onRender: RenderHandler, firstChild: Fiber, traverseSiblings: boolean) => void;
declare const updateFiberRecursively: (onRender: RenderHandler, nextFiber: Fiber, prevFiber: Fiber, parentFiber: Fiber | null) => void;
declare const unmountFiber: (onRender: RenderHandler, fiber: Fiber) => void;
declare const unmountFiberChildrenRecursively: (onRender: RenderHandler, fiber: Fiber) => void;
/**
 * Creates a fiber visitor function. Must pass a fiber root and a render handler.
 * @example
 * traverseRenderedFibers(root, (fiber, phase) => {
 *   console.log(phase)
 * })
 */
declare const traverseRenderedFibers: (root: FiberRoot, onRender: RenderHandler) => void;
/**
 * @deprecated use `traverseRenderedFibers` instead
 */
declare const createFiberVisitor: ({
  onRender
}: {
  onError: (error: unknown) => unknown;
  onRender: RenderHandler;
}) => (<S>(_rendererID: number, root: Fiber | FiberRoot, _state?: S) => void);
declare const injectOverrideMethods: () => {
  overrideContext: ((fiber: Fiber, contextType: unknown, path: string[], value: unknown) => void) | null | undefined;
  overrideHookState: ((fiber: Fiber, id: string, path: string[], value: unknown) => void) | null | undefined;
  overrideProps: ((fiber: Fiber, path: string[], value: unknown) => void) | null | undefined;
} | null | undefined;
declare const overrideProps: (fiber: Fiber, partialValue: Record<string, unknown>) => void;
declare const overrideHookState: (fiber: Fiber, id: number, partialValue: Record<string, unknown> | unknown) => void;
declare const overrideContext: (fiber: Fiber, contextType: unknown, partialValue: Record<string, unknown> | unknown) => void;
interface InstrumentationOptions {
  name?: string;
  onActive?: () => unknown;
  onCommitFiberRoot?: (rendererID: number, root: FiberRoot, priority: number | void) => unknown;
  onCommitFiberUnmount?: (rendererID: number, fiber: Fiber) => unknown;
  onPostCommitFiberRoot?: (rendererID: number, root: FiberRoot) => unknown;
  onScheduleFiberRoot?: (rendererID: number, root: FiberRoot, children: React$1.ReactNode) => unknown;
}
/**
 * Instruments the DevTools hook.
 * @example
 * const hook = instrument({
 *   onActive() {
 *     console.log('initialized');
 *   },
 *   onCommitFiberRoot(rendererID, root) {
 *     console.log('fiberRoot', root.current)
 *   },
 * });
 */
declare const instrument: (options: InstrumentationOptions) => ReactDevToolsGlobalHook;
declare const getFiberFromHostInstance: <T>(hostInstance: T) => Fiber | null;
declare const INSTALL_ERROR: Error;
declare const _fiberRoots: Set<any>;
declare const secure: (options: InstrumentationOptions, secureOptions?: {
  dangerouslyRunInProduction?: boolean;
  installCheckTimeout?: number;
  isProduction?: boolean;
  minReactMajorVersion?: number;
  onError?: (error?: unknown) => unknown;
}) => InstrumentationOptions;
/**
 * a wrapper around the {@link instrument} function that sets the `onCommitFiberRoot` hook.
 *
 * @example
 * onCommitFiberRoot((root) => {
 *   console.log(root.current);
 * });
 */
declare const onCommitFiberRoot: (handler: (root: FiberRoot) => void) => ReactDevToolsGlobalHook;

//#endregion
export { ActivityComponentTag, BIPPY_INSTRUMENTATION_STRING, BundleType, CONCURRENT_MODE_NUMBER, CONCURRENT_MODE_SYMBOL_STRING, ClassComponentTag, ComponentSelector, ContextConsumerTag, ContextDependency, DEPRECATED_ASYNC_MODE_SYMBOL_STRING, DehydratedSuspenseComponentTag, Dependencies, DevToolsConfig, ELEMENT_TYPE_SYMBOL_STRING, Effect, Family, Fiber, FiberRoot, Flags, ForwardRefTag, FragmentTag, FunctionComponentTag, HasPseudoClassSelector, HookType, HostComponentTag, HostConfig, HostHoistableTag, HostRootTag, HostSingletonTag, HostTextTag, INSTALL_ERROR, InstrumentationOptions, LanePriority, Lanes, LazyComponentTag, LegacyHiddenComponentTag, MemoComponentTag, MemoizedState, MutableSource, OffscreenComponentTag, OpaqueHandle, OpaqueRoot, Props, React$AbstractComponent, ReactConsumer, ReactContext, ReactDevToolsGlobalHook, ReactPortal, ReactProvider, ReactProviderType, ReactRenderer, RefObject, RenderHandler, RenderPhase, RoleSelector, RootTag, Selector, SimpleMemoComponentTag, Source, SuspenseComponentTag, SuspenseHydrationCallbacks, SuspenseListComponentTag, TRANSITIONAL_ELEMENT_TYPE_SYMBOL_STRING, TestNameSelector, TextSelector, Thenable, TransitionTracingCallbacks, TypeOfMode, ViewTransitionComponentTag, WorkTag, _fiberRoots, _renderers, areFiberEqual, createFiberVisitor, detectReactBuildType, didFiberCommit, didFiberRender, fiberIdMap, getDisplayName, getFiberFromHostInstance, getFiberId, getFiberStack, getLatestFiber, getMutatedHostFibers, getNearestHostFiber, getNearestHostFibers, getRDTHook, getTimings, getType, hasMemoCache, hasRDTHook, injectOverrideMethods, installRDTHook, instrument, isClientEnvironment, isCompositeFiber, isHostFiber, isInstrumentationActive, isReactRefresh, isRealReactDevtools, isValidElement, isValidFiber, mountFiberRecursively, onCommitFiberRoot, overrideContext, overrideHookState, overrideProps, patchRDTHook, safelyInstallRDTHook, secure, setFiberId, shouldFilterFiber, traverseContexts, traverseFiber, traverseFiberAsync, traverseFiberSync, traverseProps, traverseRenderedFibers, traverseState, unmountFiber, unmountFiberChildrenRecursively, updateFiberRecursively, version };